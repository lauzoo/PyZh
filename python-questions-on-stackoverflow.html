
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>8. Stackoverflow上的Python问题精选 &#8212; 一起写Python文章，一起看Python文章</title>
    <link rel="stylesheet" href="_static/rux.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="9. (译)Python的隐藏特性(StackOverflow)" href="python-hidden-features.html" />
    <link rel="prev" title="7. 让人耳目一新的Python库" href="awesome-python-libraries.html" />
   
  <script type="text/javascript"
    src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>

  </head><body>
  
  


    <div class="document">
  <div class="documentwrapper">
      <div class="bodywrapper">
        <div class="body">
          <h1 class="project-name">
            <a href="index.html">PyZh</a>
          </h1>
          <div class="nav separator">
          <span>
            <a href="index.html">Index</a>&nbsp;~ <a href="https://github.com/hit9/PyZh">Code</a>&nbsp;
            ~ <a href="https://github.com/hit9/PyZh/issues">Issues</a>&nbsp;</span>
          </div>
          <p class="flourish"><img src="_static/flourish.svg" height="60px" alt=""></p>
          <div class="body-html">
            
  <div class="section" id="stackoverflowpython">
<h1><a class="toc-backref" href="#id11">8. Stackoverflow上的Python问题精选</a><a class="headerlink" href="#stackoverflowpython" title="永久链接至标题">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">hit9</td>
</tr>
<tr class="field-even field"><th class="field-name">注1:</th><td class="field-body">以下问题来自Stackoverflow, 但不完全一致</td>
</tr>
<tr class="field-odd field"><th class="field-name">注2:</th><td class="field-body">欢迎fork向本文添加内容, 文章在Github上，地址见首页。</td>
</tr>
</tbody>
</table>
<div class="contents topic" id="id1">
<p class="topic-title first">目录</p>
<ul class="simple">
<li><a class="reference internal" href="#stackoverflowpython" id="id11">Stackoverflow上的Python问题精选</a><ul>
<li><a class="reference internal" href="#id2" id="id12">不能直接给对象设置属性?</a></li>
<li><a class="reference internal" href="#id3" id="id13">如何打印一个对象的所有属性和值的对</a></li>
<li><a class="reference internal" href="#dict" id="id14">类的__dict__无法更新?</a></li>
<li><a class="reference internal" href="#unbound-methodbound-method" id="id15">unbound method和bound method</a></li>
<li><a class="reference internal" href="#function-bound-method-unbound-method" id="id16">那么，function，bound method 和 unbound method 的区别是什么?</a></li>
<li><a class="reference internal" href="#metaclass" id="id17">什么是metaclass</a><ul>
<li><a class="reference internal" href="#id4" id="id18">什么叫做元类</a></li>
<li><a class="reference internal" href="#id5" id="id19">__metaclass__ 属性</a></li>
<li><a class="reference internal" href="#id6" id="id20">普通的元类</a></li>
<li><a class="reference internal" href="#id7" id="id21">那么你为什么用类来作为metaclass而不是函数</a></li>
<li><a class="reference internal" href="#id8" id="id22">应用场景</a></li>
<li><a class="reference internal" href="#id9" id="id23">结束语</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pythonunzip" id="id24">为什么Python没有unzip函数</a></li>
<li><a class="reference internal" href="#python" id="id25">Python中的新式类和老式类</a></li>
<li><a class="reference internal" href="#id10" id="id26">译者注</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id12">8.1. 不能直接给对象设置属性?</a><a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;whatever&quot;</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;object&#39; object has no attribute &#39;name&#39;</span>
</pre></div>
</div>
<p>但是为什么这样就可以呢:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Object</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span><span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Obj</span> <span class="o">=</span> <span class="n">Object</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Obj</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;whatever&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Obj</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;whatever&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>答: 现在你给第二个代码块中的Object加上属性 <code class="docutils literal notranslate"><span class="pre">__slots__</span></code> 试试:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Object</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Obj</span> <span class="o">=</span> <span class="n">Object</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Obj</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;whatever&quot;</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;Object&#39; object has no attribute &#39;name&#39;</span>
</pre></div>
</div>
<p>会发现抛出了同样的异常。 <code class="docutils literal notranslate"><span class="pre">object</span></code> 、 <code class="docutils literal notranslate"><span class="pre">list</span></code>  、 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 等内置函数都如此。</p>
<p>拥有 <code class="docutils literal notranslate"><span class="pre">__slots__</span></code> 属性的类在实例化对象时不会自动分配 <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> ，而 <code class="docutils literal notranslate"><span class="pre">obj.attr</span></code> 即 <code class="docutils literal notranslate"><span class="pre">obj.__dict__['attr']</span></code>,
所以会引起 <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code></p>
<p>对于拥有 <code class="docutils literal notranslate"><span class="pre">__slots__</span></code> 属性的类的实例 <code class="docutils literal notranslate"><span class="pre">Obj</span></code> 来说，只能对 <code class="docutils literal notranslate"><span class="pre">Obj</span></code> 设置 <code class="docutils literal notranslate"><span class="pre">__slots__</span></code> 中有的属性:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Object</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="s2">&quot;b&quot;</span><span class="p">}</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Obj</span> <span class="o">=</span> <span class="n">Object</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Obj</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Obj</span><span class="o">.</span><span class="n">a</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Obj</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;Object&#39; object has no attribute &#39;c&#39;</span>
</pre></div>
</div>
<p>详细见 <a class="reference external" href="http://docs.python.org/2/reference/datamodel.html#__slots__">Python-slots-doc</a></p>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id13">8.2. 如何打印一个对象的所有属性和值的对</a><a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>原问题: <a class="reference external" href="http://stackoverflow.com/questions/1251692/how-to-enumerate-an-objects-properties-in-python">http://stackoverflow.com/questions/1251692/how-to-enumerate-an-objects-properties-in-python</a></p>
<p>答:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nb">property</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="n">theObject</span><span class="p">)</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
    <span class="nb">print</span> <span class="nb">property</span><span class="p">,</span> <span class="s2">&quot;: &quot;</span><span class="p">,</span> <span class="n">value</span>
</pre></div>
</div>
<p>这个做法其实就是 <code class="docutils literal notranslate"><span class="pre">theObject.__dict__</span></code> ,  也就是 <code class="docutils literal notranslate"><span class="pre">vars(obj)</span></code> 其实就是返回了 <code class="docutils literal notranslate"><span class="pre">o.__dict__</span></code></p>
<p>另一个做法: <code class="docutils literal notranslate"><span class="pre">inspect.getmembers(object[,</span> <span class="pre">predicate])</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">inspect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmembers</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span>
</pre></div>
</div>
<p>两者不同的是， <code class="docutils literal notranslate"><span class="pre">inspect.getmembers</span></code>  返回的是元组 <code class="docutils literal notranslate"><span class="pre">(attrname,</span> <span class="pre">value)</span></code> 的列表。而且是所有的属性,  包括 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> , <code class="docutils literal notranslate"><span class="pre">__doc__</span></code> ,
<code class="docutils literal notranslate"><span class="pre">__dict__</span></code> ,  <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 等特殊命名的属性和方法。而 <code class="docutils literal notranslate"><span class="pre">vars()</span></code> 只返回 <code class="docutils literal notranslate"><span class="pre">__dict__</span></code>. 对于一个空的对象来说， <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> 会是 <code class="docutils literal notranslate"><span class="pre">{}</span></code>
,  而 <code class="docutils literal notranslate"><span class="pre">inspect.getmembers</span></code> 返回的不是空的。</p>
</div>
<div class="section" id="dict">
<h2><a class="toc-backref" href="#id14">8.3. 类的__dict__无法更新?</a><a class="headerlink" href="#dict" title="永久链接至标题">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">O</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span><span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">O</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">&#39;dictproxy&#39; object does not support item assignment</span>
</pre></div>
</div>
<p>答: 是的, class的 <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> 是只读的:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">O</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span><span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">O</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">&lt;dictproxy object at 0xb76d8ac4&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">O</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="go">[(&#39;__dict__&#39;, &lt;attribute &#39;__dict__&#39; of &#39;O&#39; objects&gt;), (&#39;__module__&#39;, &#39;__main__&#39;), (&#39;__weakref__&#39;, &lt;attribute &#39;__weakref__&#39; of &#39;O&#39; objects&gt;), (&#39;__doc__&#39;, None)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">O</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">O</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="go">[(&#39;__dict__&#39;, &lt;attribute &#39;__dict__&#39; of &#39;O&#39; objects&gt;), (&#39;__module__&#39;, &#39;__main__&#39;), (&#39;__weakref__&#39;, &lt;attribute &#39;__weakref__&#39; of &#39;O&#39; objects&gt;), (&#39;__doc__&#39;, None), (&#39;func&#39;, &lt;function &lt;lambda&gt; at 0xb76de224&gt;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">O</span><span class="o">.</span><span class="n">func</span>
<span class="go">&lt;unbound method O.&lt;lambda&gt;&gt;</span>
</pre></div>
</div>
<p>可以看到 <code class="docutils literal notranslate"><span class="pre">O.__dict__</span></code> 是一个 <code class="docutils literal notranslate"><span class="pre">dictproxy</span></code> 对象，而不是一个 <code class="docutils literal notranslate"><span class="pre">dict</span></code> . (你可以 <code class="docutils literal notranslate"><span class="pre">dir(O.__dict__)</span></code> ，但不会发现有它有属性 <code class="docutils literal notranslate"><span class="pre">__setitem__</span></code> )</p>
<p>那我们怎么给类设置属性呢? 用 <code class="docutils literal notranslate"><span class="pre">setattr</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">setattr</span><span class="p">(</span><span class="n">O</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">O</span><span class="o">.</span><span class="n">a</span>
<span class="go">1</span>
</pre></div>
</div>
</div>
<div class="section" id="unbound-methodbound-method">
<h2><a class="toc-backref" href="#id15">8.4. unbound method和bound method</a><a class="headerlink" href="#unbound-methodbound-method" title="永久链接至标题">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">foo</span>
<span class="go">&lt;unbound method C.foo&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="p">()</span><span class="o">.</span><span class="n">foo</span>
<span class="go">&lt;bound method C.foo of &lt;__main__.C object at 0xb76ddcac&gt;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>为什么 <code class="docutils literal notranslate"><span class="pre">C.foo</span></code> 是一个 <code class="docutils literal notranslate"><span class="pre">unbound</span> <span class="pre">method</span></code> , <code class="docutils literal notranslate"><span class="pre">C().foo</span></code> 是一个 <code class="docutils literal notranslate"><span class="pre">bound</span> <span class="pre">method</span></code> ？ Python 为什么这样设计?</p>
<p>答：这是问题 <a class="reference external" href="http://stackoverflow.com/questions/114214/class-method-differences-in-python-bound-unbound-and-static">http://stackoverflow.com/questions/114214/class-method-differences-in-python-bound-unbound-and-static</a></p>
<p>来自Armin Ronacher(Flask 作者)的回答:</p>
<p>如果你明白python中描述器(descriptor)是怎么实现的, 方法(method) 是很容易理解的。</p>
<p>上例代码中可以看到，如果你用类 <code class="docutils literal notranslate"><span class="pre">C</span></code> 去访问 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 方法，会得到 <code class="docutils literal notranslate"><span class="pre">unbound</span></code> 方法，然而在class的内部存储中它是个 <code class="docutils literal notranslate"><span class="pre">function</span></code>, 为什么?
原因就是 <code class="docutils literal notranslate"><span class="pre">C</span></code> 的类 (注意是类的类) 实现了一个 <code class="docutils literal notranslate"><span class="pre">__getattribute__</span></code> 来解析描述器。听起来复杂，但并非如此。上例子中的 <code class="docutils literal notranslate"><span class="pre">C.foo</span></code> 等价于:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
<span class="go">&lt;unbound method C.foo&gt;</span>
</pre></div>
</div>
<p>这是因为方法 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 有个 <code class="docutils literal notranslate"><span class="pre">__get__</span></code> 方法，也就是说, 方法是个描述器。如果你用实例来访问的话也是一模一样的:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
<span class="go">&lt;bound method C.foo of &lt;__main__.C object at 0xb76ddd8c&gt;&gt;</span>
</pre></div>
</div>
<p>只是那个 <code class="docutils literal notranslate"><span class="pre">None</span></code> 换成了这个实例。</p>
<p>现在我们来讨论，为什么Python要这么设计?</p>
<p>其实，所谓 <code class="docutils literal notranslate"><span class="pre">bound</span> <span class="pre">method</span></code> ，就是方法对象的第一个函数参数绑定为了这个类的实例(所谓 <code class="docutils literal notranslate"><span class="pre">bind</span></code> )。这也是那个 <code class="docutils literal notranslate"><span class="pre">self</span></code> 的由来。</p>
<p>当你不想让类把一个函数作为一个方法，可以使用装饰器 <code class="docutils literal notranslate"><span class="pre">staticmethod</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nd">@staticmethod</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">foo</span>
<span class="go">&lt;function foo at 0xb76d056c&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
<span class="go">&lt;function foo at 0xb76d056c&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">staticmethod</span></code> 装饰器会让 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 的 <code class="docutils literal notranslate"><span class="pre">__get__</span></code> 返回一个函数，而不是一个方法。</p>
</div>
<div class="section" id="function-bound-method-unbound-method">
<h2><a class="toc-backref" href="#id16">8.5. 那么，function，bound method 和 unbound method 的区别是什么?</a><a class="headerlink" href="#function-bound-method-unbound-method" title="永久链接至标题">¶</a></h2>
<p>一个函数(function)是由 <code class="docutils literal notranslate"><span class="pre">def</span></code> 语句或者 <code class="docutils literal notranslate"><span class="pre">lambda</span></code> 创建的。</p>
<p>当一个函数(function)定义在了class语句的块中（或者由 <code class="docutils literal notranslate"><span class="pre">type</span></code> 来创建的), 它会转成一个 <code class="docutils literal notranslate"><span class="pre">unbound</span> <span class="pre">method</span></code> , 当我们通过一个类的实例来
访问这个函数的时候，它就转成了 <code class="docutils literal notranslate"><span class="pre">bound</span> <span class="pre">method</span></code> , <code class="docutils literal notranslate"><span class="pre">bound</span> <span class="pre">method</span></code> 会自动把这个实例作为函数的地一个参数。</p>
<p>所以， <code class="docutils literal notranslate"><span class="pre">bound</span> <span class="pre">method</span></code> 就是绑定了一个实例的方法， 否则叫做 <code class="docutils literal notranslate"><span class="pre">unbound</span> <span class="pre">method</span></code> .它们都是方法(method), 是出现在 <code class="docutils literal notranslate"><span class="pre">class</span></code> 中的函数。</p>
</div>
<div class="section" id="metaclass">
<h2><a class="toc-backref" href="#id17">8.6. 什么是metaclass</a><a class="headerlink" href="#metaclass" title="永久链接至标题">¶</a></h2>
<p>这是stackoverflow投票很高的问题: <a class="reference external" href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python</a></p>
<p>回答: (最高得分的答案)</p>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id18">8.6.1. 什么叫做元类</a><a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>Metaclass是创建class的东西。</p>
<p>一个class是用来创建对象的是不是?</p>
<p>但是我们知道，Python中的类也是对象。</p>
<p>Metaclass就是用来创建类这些对象的，它们是类的类，你可以形象化地理解为:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MyClass</span> <span class="o">=</span> <span class="n">MetaClass</span><span class="p">()</span>
<span class="n">MyObject</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
</pre></div>
</div>
<p>你知道， <code class="docutils literal notranslate"><span class="pre">type</span></code> 函数可以这样使用:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MyClass</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;MyClass&#39;</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{})</span>
</pre></div>
</div>
<p>这是因为 <code class="docutils literal notranslate"><span class="pre">type</span></code> 实际上是个 <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> , Python使用 <code class="docutils literal notranslate"><span class="pre">type</span></code> 这个元类来创建所有的类。</p>
<p>现在你是不是有疑问了，为什么 <code class="docutils literal notranslate"><span class="pre">type</span></code> 是小写开头的，而不是 <code class="docutils literal notranslate"><span class="pre">Type</span></code> 呢？既然它是个元类！</p>
<p>我猜，大概是因为和 <code class="docutils literal notranslate"><span class="pre">str</span></code> , <code class="docutils literal notranslate"><span class="pre">int</span></code> 来保持一致吧， <code class="docutils literal notranslate"><span class="pre">str</span></code> 也是一个类，用来创建字符串。</p>
<p>你可以检查下对象的 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 属性来看看它们的类是谁. Python中万物都是对象:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">age</span> <span class="o">=</span> <span class="mi">35</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">age</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;type &#39;int&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;bob&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;type &#39;str&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span><span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;type &#39;function&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;class &#39;__main__.Bar&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>那么， <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 的 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 属性又是谁?</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;type &#39;type&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;bob&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;type &#39;type&#39;&gt;</span>
</pre></div>
</div>
<p>所以，元类是用来创建类的。</p>
<p>你可以叫元类为 <em>类工厂</em></p>
<p><code class="docutils literal notranslate"><span class="pre">type</span></code> 是Python使用的内建元类，当然，Python允许大家建立自己的元类.</p>
</div>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id19">8.6.2. __metaclass__ 属性</a><a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>你可以在写一个类的时候加上这个属性 <code class="docutils literal notranslate"><span class="pre">__metaclass__</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">something</span><span class="o">...</span>
  <span class="p">[</span><span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>这样的话，Python就会用这个元类(上例中为 <code class="docutils literal notranslate"><span class="pre">something</span></code> ) 来创建类 <code class="docutils literal notranslate"><span class="pre">Foo</span></code></p>
<p>我们首先写的是 <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Foo(object)</span></code> ,但是Python跑到这里看到这一行时，并没有在内存中建立类 <code class="docutils literal notranslate"><span class="pre">Foo</span></code></p>
<p><strong>因为Python这么做的：查找它有没有 ``__metaclass__`` 属性，有的话，用指定的类来创建 ``Foo`` ,否则（也就是一般情形下），使用 ``type`` 来创建</strong></p>
<p>最好还是记住上面那句话 :)</p>
<p>当你这么写的时候:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="n">Bar</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Python会这么做:</p>
<ol class="arabic simple">
<li>有 <code class="docutils literal notranslate"><span class="pre">__metaclass__</span></code> 定义吗？ 如果有，在内存中建立一个类的对象。用 <code class="docutils literal notranslate"><span class="pre">__metaclass__</span></code> 指定的类来创建。</li>
<li>如果没有找到这个属性，它会继续在父类 <code class="docutils literal notranslate"><span class="pre">Bar</span></code> 中找</li>
<li>这样一直向父类找，父类的父类。。。直到 module 级别的才停止。</li>
<li>如果在任何的父类中都找不到，那就用 <code class="docutils literal notranslate"><span class="pre">type</span></code> 创建 <code class="docutils literal notranslate"><span class="pre">Foo</span></code></li>
</ol>
<p>现在一个问题，我们可以给 <code class="docutils literal notranslate"><span class="pre">__metaclass__</span></code> 赋值什么呢?</p>
<p>答案当然是，一个可以创建类的东西。</p>
<p>那么，什么才能创建一个类呢？</p>
</div>
<div class="section" id="id6">
<h3><a class="toc-backref" href="#id20">8.6.3. 普通的元类</a><a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>设计元类的主要目的就是允许我们在类创建的时候动态的修改它，这经常用在API的设计上。</p>
<p>让我们举一个很纯的例子，比如你想要让一个模块中的所有类都共享一些属性，有很多办法可以做到，其中一个就是
在模块中定义一个 <code class="docutils literal notranslate"><span class="pre">__metaclass__</span></code> 属性。</p>
<p>这样，模块中所有的类都会被 <code class="docutils literal notranslate"><span class="pre">__metaclass__</span></code> 创建。</p>
<p>幸运的是 , <code class="docutils literal notranslate"><span class="pre">__metaclass__</span></code> 可以是任何可以被调用的对象。不非要是个class，还可以是个函数。</p>
<p>所以，我们这么做,用一个函数来作为metaclass:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># the metaclass will automatically get passed the same argument</span>
<span class="c1"># that you usually pass to `type`</span>
<span class="k">def</span> <span class="nf">upper_attr</span><span class="p">(</span><span class="n">future_class_name</span><span class="p">,</span> <span class="n">future_class_parents</span><span class="p">,</span> <span class="n">future_class_attr</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a class object, with the list of its attribute turned</span>
<span class="sd">    into uppercase.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="c1"># pick up any attribute that doesn&#39;t start with &#39;__&#39;</span>
  <span class="n">attrs</span> <span class="o">=</span> <span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">future_class_attr</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">))</span>
  <span class="c1"># turn them into uppercase</span>
  <span class="n">uppercase_attr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">)</span>

  <span class="c1"># let `type` do the class creation</span>
  <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">future_class_name</span><span class="p">,</span> <span class="n">future_class_parents</span><span class="p">,</span> <span class="n">uppercase_attr</span><span class="p">)</span>

<span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">upper_attr</span> <span class="c1"># this will affect all classes in the module</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">():</span> <span class="c1"># global __metaclass__ won&#39;t work with &quot;object&quot; though</span>
  <span class="c1"># but we can define __metaclass__ here instead to affect only this class</span>
  <span class="c1"># and this will work with &quot;object&quot; children</span>
  <span class="n">bar</span> <span class="o">=</span> <span class="s1">&#39;bip&#39;</span>

<span class="nb">print</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">)</span>
<span class="c1"># Out: False</span>
<span class="nb">print</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="s1">&#39;BAR&#39;</span><span class="p">)</span>
<span class="c1"># Out: True</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="nb">print</span> <span class="n">f</span><span class="o">.</span><span class="n">BAR</span>
<span class="c1"># Out: &#39;bip&#39;</span>
</pre></div>
</div>
<p>现在我们用一个类来作为一个metaclass:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># remember that `type` is actually a class like `str` and `int`</span>
<span class="c1"># so you can inherit from it</span>
<span class="k">class</span> <span class="nc">UpperAttrMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="c1"># __new__ is the method called before __init__</span>
    <span class="c1"># it&#39;s the method that creates the object and returns it</span>
    <span class="c1"># while __init__ just initializes the object passed as parameter</span>
    <span class="c1"># you rarely use __new__, except when you want to control how the object</span>
    <span class="c1"># is created.</span>
    <span class="c1"># here the created object is the class, and we want to customize it</span>
    <span class="c1"># so we override __new__</span>
    <span class="c1"># you can do some stuff in __init__ too if you wish</span>
    <span class="c1"># some advanced use involves overriding __call__ as well, but we won&#39;t</span>
    <span class="c1"># see this</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">upperattr_metaclass</span><span class="p">,</span> <span class="n">future_class_name</span><span class="p">,</span>
                <span class="n">future_class_parents</span><span class="p">,</span> <span class="n">future_class_attr</span><span class="p">):</span>

        <span class="n">attrs</span> <span class="o">=</span> <span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">future_class_attr</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">))</span>
        <span class="n">uppercase_attr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">future_class_name</span><span class="p">,</span> <span class="n">future_class_parents</span><span class="p">,</span> <span class="n">uppercase_attr</span><span class="p">)</span>
</pre></div>
</div>
<p>但这样并不是很 OOP ， 我们可以直接调用 <code class="docutils literal notranslate"><span class="pre">type</span></code> 函数，并且不覆盖父亲的 <code class="docutils literal notranslate"><span class="pre">__new__</span></code> 方法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">UpperAttrMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">upperattr_metaclass</span><span class="p">,</span> <span class="n">future_class_name</span><span class="p">,</span>
                <span class="n">future_class_parents</span><span class="p">,</span> <span class="n">future_class_attr</span><span class="p">):</span>

        <span class="n">attrs</span> <span class="o">=</span> <span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">future_class_attr</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">))</span>
        <span class="n">uppercase_attr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c1"># reuse the type.__new__ method</span>
        <span class="c1"># this is basic OOP, nothing magic in there</span>
        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">upperattr_metaclass</span><span class="p">,</span> <span class="n">future_class_name</span><span class="p">,</span>
                            <span class="n">future_class_parents</span><span class="p">,</span> <span class="n">uppercase_attr</span><span class="p">)</span>
</pre></div>
</div>
<p>你可能注意到了参数 <code class="docutils literal notranslate"><span class="pre">upperattr_metaclass</span></code> ,没什么特殊的，一个方法总是拿那个实例来作为第一个参数。就像寻常的 <code class="docutils literal notranslate"><span class="pre">self</span></code> 参数。</p>
<p>当然，可以这么写，我上面的例子命名不那么好:)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">UpperAttrMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">):</span>

        <span class="n">attrs</span> <span class="o">=</span> <span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">dct</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">))</span>
        <span class="n">uppercase_attr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">uppercase_attr</span><span class="p">)</span>
</pre></div>
</div>
<p>我们可以使用 <code class="docutils literal notranslate"><span class="pre">super</span></code>  函数来让这个例子变得更简洁:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">UpperAttrMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">):</span>

        <span class="n">attrs</span> <span class="o">=</span> <span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">dct</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">))</span>
        <span class="n">uppercase_attr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">UpperAttrMetaclass</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">uppercase_attr</span><span class="p">)</span>
</pre></div>
</div>
<p>元类是个简单的魔术，只要:</p>
<ul class="simple">
<li>注入类的创建</li>
<li>修改类</li>
<li>返回修改后的类</li>
</ul>
</div>
<div class="section" id="id7">
<h3><a class="toc-backref" href="#id21">8.6.4. 那么你为什么用类来作为metaclass而不是函数</a><a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>既然 <code class="docutils literal notranslate"><span class="pre">__metaclass__</span></code> 可以是任何可以被调用的对象，那么你为什么用类作为metaclass而不是函数呢？</p>
<p>几个原因:</p>
<ul class="simple">
<li>更能清楚的表达意图</li>
<li>可以使用OOP, metaclass可以继承，重写父类，甚至使用metaclass，可以使用面向对象的特性。</li>
<li>更好的组织代码.</li>
<li></li>
</ul>
</div>
<div class="section" id="id8">
<h3><a class="toc-backref" href="#id22">8.6.5. 应用场景</a><a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>一个典型例子，Django ORM (译者注,peewee也用metaclass):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
    <span class="n">age</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">()</span>
</pre></div>
</div>
<p>但是你这么做:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">guy</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;bob&#39;</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="s1">&#39;35&#39;</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">guy</span><span class="o">.</span><span class="n">age</span>
</pre></div>
</div>
<p>并不返回一个 <code class="docutils literal notranslate"><span class="pre">IntegerField</span></code> 对象，而是一个 <code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</div>
<div class="section" id="id9">
<h3><a class="toc-backref" href="#id23">8.6.6. 结束语</a><a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p>Python的世界里，万物都是对象</p>
<p>但是 <code class="docutils literal notranslate"><span class="pre">type</span></code> 是它自己的元类。</p>
<p>99%的情形下你不需要用这个东西。</p>
</div>
</div>
<div class="section" id="pythonunzip">
<h2><a class="toc-backref" href="#id24">8.7. 为什么Python没有unzip函数</a><a class="headerlink" href="#pythonunzip" title="永久链接至标题">¶</a></h2>
<p>众所周知, <code class="docutils literal notranslate"><span class="pre">zip</span></code> 函数可以把多个序列打包到元组中:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">[(1, 4), (2, 5), (3, 6)]</span>
</pre></div>
</div>
<p>那么为什么没有这样的 <code class="docutils literal notranslate"><span class="pre">unzip</span></code> 函数来把 <code class="docutils literal notranslate"><span class="pre">[(1,</span> <span class="pre">4),</span> <span class="pre">(2,</span> <span class="pre">5),</span> <span class="pre">(3,</span> <span class="pre">6)]</span></code> 还原呢?</p>
<p>答: Python中有个很神奇的操作符 <code class="docutils literal notranslate"><span class="pre">*</span></code> 来 <code class="docutils literal notranslate"><span class="pre">unpack</span></code> 参数列表:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="go">[(1, 2, 3), (4, 5, 6)]</span>
</pre></div>
</div>
</div>
<div class="section" id="python">
<h2><a class="toc-backref" href="#id25">8.8. Python中的新式类和老式类</a><a class="headerlink" href="#python" title="永久链接至标题">¶</a></h2>
<p>无论你怎么叫吧， 英文来说是 <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">style</span> <span class="pre">class</span></code> 和 <code class="docutils literal notranslate"><span class="pre">old</span> <span class="pre">style</span> <span class="pre">class</span></code></p>
<p>问题链接: <a class="reference external" href="http://stackoverflow.com/questions/54867/old-style-and-new-style-classes-in-python">http://stackoverflow.com/questions/54867/old-style-and-new-style-classes-in-python</a></p>
<p>新式类是继承自 <code class="docutils literal notranslate"><span class="pre">object</span></code> 或其他新式类的类:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NewStyleClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">AnotherNewStyleClass</span><span class="p">(</span><span class="n">NewStyleClass</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>否则是老式类:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">OldStyleClass</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p><strong>为什么引入新式类?</strong></p>
<p>&gt; The major motivation for introducing new-style classes is to provide a unified object model with a full meta-model.</p>
<p>Python为了提供一个更完整的元模型。(好吧，译者也不大明白，不过我知道Python中很神奇的描述器只能在新式类里用)</p>
</div>
<div class="section" id="id10">
<h2><a class="toc-backref" href="#id26">8.9. 译者注</a><a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<p>本文Github地址: <a class="reference external" href="https://github.com/HIT-ON-Github/PyZh/blob/master/docs/python-questions-on-stackoverflow.rst">https://github.com/HIT-ON-Github/PyZh/blob/master/docs/python-questions-on-stackoverflow.rst</a></p>
<p>欢迎Fork追加问题。</p>
</div>
</div>


            <div class="cut">***</div>
          </div>
       </div>
     </div>
  </div>
      <div class="clearer"></div>
    </div>
  
  <a href="http://github.com/hit9/PyZh">
    <img style="position: fixed; top: 0; right: 0; border: 0;"
    src="http://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"
    alt="Fork me on GitHub" />
  </a>
  

  
  <div class="footer">
    &copy; Copyright 2013, hit9.
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>. Theme
    <a href="https://github.com/hit9/sphinx-theme-rux">rux</a>.
  </div>

  </body>
</html>