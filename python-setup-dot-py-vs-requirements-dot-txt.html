
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>12. setup.py vs requirements.txt &#8212; 一起写Python文章，一起看Python文章</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/rux.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/translations.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="13. Python Realtime" href="python-realtime.html" />
    <link rel="prev" title="11. (译)Python魔法方法指南" href="python-magic-methods-guide.html" />
   
  <script type="text/javascript"
    src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>

  </head><body>
  
  


    <div class="document">
  <div class="documentwrapper">
      <div class="bodywrapper">
        <div class="body">
          <h1 class="project-name">
            <a href="index.html">PyZh</a>
          </h1>
          <div class="nav separator">
          <span>
            <a href="index.html">Index</a>&nbsp;~ <a href="https://github.com/hit9/PyZh">Code</a>&nbsp;
            ~ <a href="https://github.com/hit9/PyZh/issues">Issues</a>&nbsp;</span>
          </div>
          <p class="flourish"><img src="_static/flourish.svg" height="60px" alt=""></p>
          <div class="body-html">
            
  <div class="section" id="setup-py-vs-requirements-txt">
<h1><a class="toc-backref" href="#id6"><span class="section-number">12. </span>setup.py vs requirements.txt</a><a class="headerlink" href="#setup-py-vs-requirements-txt" title="永久链接至标题">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">原文</dt>
<dd class="field-odd"><p><a class="reference external" href="https://caremad.io/blog/setup-vs-requirement/">https://caremad.io/blog/setup-vs-requirement/</a></p>
</dd>
<dt class="field-even">作者</dt>
<dd class="field-even"><p>Donald</p>
</dd>
<dt class="field-odd">译</dt>
<dd class="field-odd"><p>hit9</p>
</dd>
</dl>
<div class="contents topic" id="id1">
<p class="topic-title">目录</p>
<ul class="simple">
<li><p><a class="reference internal" href="#setup-py-vs-requirements-txt" id="id6">setup.py vs requirements.txt</a></p>
<ul>
<li><p><a class="reference internal" href="#python" id="id7">Python库</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id8">Python应用</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id9">那么，抽象和具体又有什么关系呢？</a></p></li>
<li><p><a class="reference internal" href="#setuptoolsdependency-links" id="id10">Setuptools的dependency_links</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id11">开发可复用的包与不重复自己</a></p></li>
</ul>
</li>
</ul>
</div>
<p>对于 <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> 和 <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code>
的角色有很多误解，很多人认为它们是两个重复的事情，甚至创造了 <a class="reference external" href="https://pypi.python.org/pypi/pbr/#requirements">工具</a> 来处理
这种“重复”。</p>
<div class="section" id="python">
<h2><a class="toc-backref" href="#id7"><span class="section-number">12.1. </span>Python库</a><a class="headerlink" href="#python" title="永久链接至标题">¶</a></h2>
<p>这里所说的Python库是指那些被开发并且为了其他人来使用而发布的东西，你可以在
<a class="reference external" href="https://pypi.python.org/pypi">PyPI</a> 找到很多Python库。为了更好的推广和传播
自己，Python库会包含很多的信息，比如它的名字，版本号，依赖等等。而 <code class="docutils literal notranslate"><span class="pre">setup.py</span></code>
就是用来提供这些信息的:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>

<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;MyLibrary&quot;</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="s2">&quot;1.0&quot;</span><span class="p">,</span>
    <span class="n">install_requires</span><span class="o">=</span><span class="p">[</span>
        <span class="s2">&quot;requests&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bcrypt&quot;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="c1"># ...</span>
<span class="p">)</span>
</pre></div>
</div>
<p>这样很简单地声明了这个Python库的一些信息。但是，你并没有看到你可以从哪里获取这些依赖库。
这里并没有提供一个url或者一个文件系统来获取这些依赖，而只是告诉我们依赖是
<code class="docutils literal notranslate"><span class="pre">requests</span></code> ， <code class="docutils literal notranslate"><span class="pre">bcrypt</span></code>
，这很重要，我们可以称这种声明方式为“抽象的依赖”，它们只是以名字（或者加上了一个具体的版本号）
的方式来出现的。这就像我们说的“鸭子类型”，你不在乎它是什么样子的只要它看起来是 <code class="docutils literal notranslate"><span class="pre">requests</span></code> 。</p>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id8"><span class="section-number">12.2. </span>Python应用</a><a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>这里所讲的Python应用是指你所要部署的一些东西，这是区别于我们之前所讲的Python库的。Python应用或许可以在
PyPI上找到，但是不像Python库，它们并不是一种可以被开发者使用多次的工具性的东西。PyPI上的Python应用经常会
在这个应用的旁边放置一个文件用来声明该应用部署的依赖。</p>
<p>一个应用经常会有很多依赖，或许会很复杂。这些依赖里很多没有一个名字，或者没有我们说所的那些信息。这便反映了 <a class="reference external" href="http://pip-installer.org/">pip</a>
的requirements文件所做的事情了，一个典型的requirements文件看起来是这样的:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># This is an implicit value, here for clarity</span>
<span class="o">--</span><span class="n">index</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">pypi</span><span class="o">.</span><span class="n">python</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">simple</span><span class="o">/</span>

<span class="n">MyPackage</span><span class="o">==</span><span class="mf">1.0</span>
<span class="n">requests</span><span class="o">==</span><span class="mf">1.2</span><span class="o">.</span><span class="mi">0</span>
<span class="n">bcrypt</span><span class="o">==</span><span class="mf">1.0</span><span class="o">.</span><span class="mi">2</span>
</pre></div>
</div>
<p>这里每个依赖都标明了准确的版本号，一般一个Python库对依赖的版本比较宽松，而一个应用則会依赖比较具体的版本号。虽然也许跑其他
版本的 <code class="docutils literal notranslate"><span class="pre">requests</span></code>
并不会出错，但是我们在本地测试顺利后，我们就会希望在线上也跑相同的版本。</p>
<p>文件的头部有一个 <code class="docutils literal notranslate"><span class="pre">--index</span> <span class="pre">https://pypi.python.org/simple/</span></code>
，一般如果你不用声明这项，除非你使用的不是PyPI。然而它却是 <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code> 的一个重要部分，
这一行把一个抽象的依赖声明 <code class="docutils literal notranslate"><span class="pre">requests==1.2.0</span></code> 转变为一个具体的依赖声明 <code class="docutils literal notranslate"><span class="pre">requests</span> <span class="pre">1.2.0</span> <span class="pre">from</span> <span class="pre">pypi.python.org/simple/</span></code>
，这不像“鸭子类型”，倒像一次 <code class="docutils literal notranslate"><span class="pre">isinstance</span></code> 检查。</p>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id9"><span class="section-number">12.3. </span>那么，抽象和具体又有什么关系呢？</a><a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>读到这里你或许会说，OK, 我已经知道 <code class="docutils literal notranslate"><span class="pre">setup.py</span></code>
是为可发行的Python库那些包准备的，而 <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code>
是为那些不被经常作为工具利用的Python应用准备的，但是我已经把我的
<code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code> 读进来填充了我的 <code class="docutils literal notranslate"><span class="pre">install_requires=[...]</span></code> 啊（译者注：
比如你在 <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> 中把 <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code>
文件读取进来并切割成行列表，赋值给关键字
<code class="docutils literal notranslate"><span class="pre">install_requires</span></code>)，那我为何要在乎这个区别呢？</p>
<p>对于抽象依赖和具体依赖的区分是非常重要的，这点使我们的PyPI镜像源正常工作，这点允许我们可以在公司里搭建我们
私有的包索引服务，甚至这点允许了你去fork一个包并改造它。因为一个抽象的依赖只是一个名字和一个可选的版本号，你可以从
PyPi来安装它，或者从你自己的文件系统，你可以fork它并改造它，只要你指明了正确的名字和版本号你就可以一直这么使用下去。</p>
<p>一个极端点的情况是，你在该使用抽象依赖的地方使用了具体的依赖，这在Go语言中可以看到</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;github.com/foo/bar&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>这里我们指明了一个具体的url。现在如果我以这种指明url的方式使用了这个库，而且现在我想要改造这个库（比如它缺失了我想要的某个功能，
或者有一个讨厌的bug)。我可能不仅仅需要fork <code class="docutils literal notranslate"><span class="pre">bar</span></code>
这个库，还需要fork依赖这个库的其他库。(译者注：也就是说，想要替换一个底层依赖的话，需要改动依赖这个库的其他依赖对该库的依赖声明。)</p>
</div>
<div class="section" id="setuptoolsdependency-links">
<h2><a class="toc-backref" href="#id10"><span class="section-number">12.4. </span>Setuptools的dependency_links</a><a class="headerlink" href="#setuptoolsdependency-links" title="永久链接至标题">¶</a></h2>
<p>Setuptools有一个功能叫做 <a class="reference external" href="http://pythonhosted.org/setuptools/setuptools.html#dependencies-that-aren-t-in-pypi">dependency_links</a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>

<span class="n">setup</span><span class="p">(</span>
    <span class="c1"># ...</span>
    <span class="n">dependency_links</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;http://packages.example.com/snapshots/&quot;</span><span class="p">,</span>
        <span class="s2">&quot;http://example2.com/p/bar-1.0.tar.gz&quot;</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">)</span>
</pre></div>
</div>
<p>这一功能除去了依赖的抽象特性，直接把依赖的获取url标在了setup.py里。就像在Go语言中修改依赖包一样，我们只需要修改依赖链中每个包的 <code class="docutils literal notranslate"><span class="pre">dependency_links</span></code> 。</p>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id11"><span class="section-number">12.5. </span>开发可复用的包与不重复自己</a><a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>那么我们写依赖声明的时候需要在 <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> 中写好抽象依赖，在 <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code> 中写好具体的依赖，但是我们并不想维护两份依赖文件，这样会让我们很难
做好同步。 <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code> 可以更好地处理这种情况，我们可以在有 <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> 的目录里写下一个这样的 <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">--</span><span class="n">index</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">pypi</span><span class="o">.</span><span class="n">python</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">simple</span><span class="o">/</span>

<span class="o">-</span><span class="n">e</span> <span class="o">.</span>
</pre></div>
</div>
<p>这样 <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">-r</span> <span class="pre">requirements.txt</span></code> 可以照常工作，它会先安装该文件路径下的包，然后继续开始解析抽象依赖，结合 <code class="docutils literal notranslate"><span class="pre">--index</span></code> 选项后转换为具体依赖然后再安装她们。</p>
<p>这个办法可以让我们解决一种类似这样的情形：比如你有两个或两个以上的包在一起开发但是是分开发行的，或者说你有一个尚未发布的包并把它分成了几个部分。如果你的顶层的包
依然仅仅按照“名字”来依赖的话，我们依然可以使用 <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code> 来安装开发版本的依赖包:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">--</span><span class="n">index</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">pypi</span><span class="o">.</span><span class="n">python</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">simple</span><span class="o">/</span>

<span class="o">-</span><span class="n">e</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">foo</span><span class="o">/</span><span class="n">bar</span><span class="o">.</span><span class="n">git</span><span class="c1">#egg=bar</span>
<span class="o">-</span><span class="n">e</span> <span class="o">.</span>
</pre></div>
</div>
<p>这会首先从 <a class="reference external" href="https://github.com/foo/bar.git">https://github.com/foo/bar.git</a> 来安装包 <code class="docutils literal notranslate"><span class="pre">bar</span></code> ， 然后进行到第二行 <code class="docutils literal notranslate"><span class="pre">-e</span> <span class="pre">.</span></code> ，开始安装 <code class="docutils literal notranslate"><span class="pre">setup</span></code> 中的抽象依赖，但是包 <code class="docutils literal notranslate"><span class="pre">bar</span></code> 已经安装过了，
所以 pip 会跳过安装，而是仍然使用github.com上安装了的开发版本的包 <code class="docutils literal notranslate"><span class="pre">bar</span></code> 。</p>
</div>
</div>


            <div class="cut">***</div>
          </div>
       </div>
     </div>
  </div>
      <div class="clearer"></div>
    </div>
  
  <a href="http://github.com/hit9/PyZh">
    <img style="position: fixed; top: 0; right: 0; border: 0;"
    src="http://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"
    alt="Fork me on GitHub" />
  </a>
  

  
  <div class="footer">
    &copy; Copyright 2013, hit9.
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>. Theme
    <a href="https://github.com/hit9/sphinx-theme-rux">rux</a>.
  </div>

  </body>
</html>