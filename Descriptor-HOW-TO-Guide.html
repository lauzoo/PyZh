
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>1. Python描述器引导(翻译) &#8212; 一起写Python文章，一起看Python文章</title>
    <link rel="stylesheet" href="_static/rux.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="2. Python:字典的剧本(翻译自Python:The Dictionary Playbook)" href="python-the-dictionary-playbook.html" />
    <link rel="prev" title="PyZh" href="index.html" />
   
  <script type="text/javascript"
    src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>

  </head><body>
  
  


    <div class="document">
  <div class="documentwrapper">
      <div class="bodywrapper">
        <div class="body">
          <h1 class="project-name">
            <a href="index.html">PyZh</a>
          </h1>
          <div class="nav separator">
          <span>
            <a href="index.html">Index</a>&nbsp;~ <a href="https://github.com/hit9/PyZh">Code</a>&nbsp;
            ~ <a href="https://github.com/hit9/PyZh/issues">Issues</a>&nbsp;</span>
          </div>
          <p class="flourish"><img src="_static/flourish.svg" height="60px" alt=""></p>
          <div class="body-html">
            
  <div class="section" id="python">
<h1><a class="toc-backref" href="#id9">1. Python描述器引导(翻译)</a><a class="headerlink" href="#python" title="永久链接至标题">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">作者:</th><td class="field-body">Raymond Hettinger</td>
</tr>
<tr class="field-even field"><th class="field-name">联系:</th><td class="field-body">&lt;python at rcn dot com&gt;</td>
</tr>
<tr class="field-odd field"><th class="field-name">翻译:</th><td class="field-body">hit9, iceout</td>
</tr>
<tr class="field-even field"><th class="field-name">译者注:</th><td class="field-body">原文链接- <a class="reference external" href="http://docs.python.org/2/howto/descriptor.html">http://docs.python.org/2/howto/descriptor.html</a></td>
</tr>
</tbody>
</table>
<div class="contents topic" id="id1">
<p class="topic-title first">目录</p>
<ul class="simple">
<li><a class="reference internal" href="#python" id="id9">Python描述器引导(翻译)</a><ul>
<li><a class="reference internal" href="#id2" id="id10">摘要</a></li>
<li><a class="reference internal" href="#id3" id="id11">定义和介绍</a></li>
<li><a class="reference internal" href="#id4" id="id12">描述器协议</a></li>
<li><a class="reference internal" href="#id5" id="id13">描述器的调用</a></li>
<li><a class="reference internal" href="#id6" id="id14">描述器例子</a></li>
<li><a class="reference internal" href="#properties" id="id15">属性(properties)</a></li>
<li><a class="reference internal" href="#id7" id="id16">函数和方法</a></li>
<li><a class="reference internal" href="#id8" id="id17">静态方法和类方法</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id10">1.1. 摘要</a><a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>定义描述器, 总结描述器协议，并展示描述器是怎么被调用的。展示一个自定义的描述器和包括函数，属性(property), 静态方法(static method), 类方法在内的几个Python内置描述器。通过给出一个纯Python的实现和示例应用来展示每个描述器是怎么工作的。</p>
<p>学习描述器不仅让你接触到更多的工具，还可以让你更深入地了解Python，让你体会到Python设计的优雅之处。</p>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id11">1.2. 定义和介绍</a><a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>一般来说，一个描述器是一个有“绑定行为”的对象属性(object attribute)，它的访问控制被描述器协议方法重写。这些方法是 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code>, 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code> 。有这些方法的对象叫做描述器。</p>
<p>默认对属性的访问控制是从对象的字典里面(__dict__)中获取(get), 设置(set)和删除(delete)它。举例来说， <code class="docutils literal notranslate"><span class="pre">a.x</span></code>  的查找顺序是, <code class="docutils literal notranslate"><span class="pre">a.__dict__['x']</span></code> , 然后 <code class="docutils literal notranslate"><span class="pre">type(a).__dict__['x']</span></code> , 然后找 <code class="docutils literal notranslate"><span class="pre">type(a)</span></code> 的父类(不包括元类(metaclass)).如果查找到的值是一个描述器, Python就会调用描述器的方法来重写默认的控制行为。这个重写发生在这个查找环节的哪里取决于定义了哪个描述器方法。注意, 只有在新式类中时描述器才会起作用。(新式类是继承自 <code class="docutils literal notranslate"><span class="pre">type</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">object</span></code> 的类)</p>
<p>描述器是强大的，应用广泛的。描述器正是属性, 实例方法, 静态方法, 类方法和 <code class="docutils literal notranslate"><span class="pre">super</span></code> 的背后的实现机制。描述器在Python自身中广泛使用，以实现Python 2.2中引入的新式类。描述器简化了底层的C代码，并为Python的日常编程提供了一套灵活的新工具。</p>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id12">1.3. 描述器协议</a><a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">descr.__get__(self,</span> <span class="pre">obj,</span> <span class="pre">type=None)</span> <span class="pre">--&gt;</span> <span class="pre">value</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">descr.__set__(self,</span> <span class="pre">obj,</span> <span class="pre">value)</span> <span class="pre">--&gt;</span> <span class="pre">None</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">descr.__delete__(self,</span> <span class="pre">obj)</span> <span class="pre">--&gt;</span> <span class="pre">None</span></code></p>
<p>这是所有描述器方法。一个对象具有其中任一个方法就会成为描述器，从而在被当作对象属性时重写默认的查找行为。</p>
<p>如果一个对象同时定义了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code>,它叫做资料描述器(data descriptor)。仅定义了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> 的描述器叫非资料描述器(常用于方法，当然其他用途也是可以的)</p>
<p>资料描述器和非资料描述器的区别在于：相对于实例的字典的优先级。如果实例字典中有与描述器同名的属性，如果描述器是资料描述器，优先使用资料描述器，如果是非资料描述器，优先使用字典中的属性。(译者注：这就是为何实例 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的方法和属性重名时，比如都叫 <code class="docutils literal notranslate"><span class="pre">foo</span></code> Python会在访问 <code class="docutils literal notranslate"><span class="pre">a.foo</span></code> 的时候优先访问实例字典中的属性，因为实例函数的实现是个非资料描述器)</p>
<p>要想制作一个只读的资料描述器，需要同时定义 <code class="docutils literal notranslate"><span class="pre">__set__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__get__</span></code>,并在 <code class="docutils literal notranslate"><span class="pre">__set__</span></code> 中引发一个 <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code> 异常。定义一个引发异常的 <code class="docutils literal notranslate"><span class="pre">__set__</span></code> 方法就足够让一个描述器成为资料描述器。</p>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id13">1.4. 描述器的调用</a><a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>描述器可以直接这么调用：    <code class="docutils literal notranslate"><span class="pre">d.__get__(obj)</span></code></p>
<p>然而更常见的情况是描述器在属性访问时被自动调用。举例来说， <code class="docutils literal notranslate"><span class="pre">obj.d</span></code> 会在 <code class="docutils literal notranslate"><span class="pre">obj</span></code> 的字典中找 <code class="docutils literal notranslate"><span class="pre">d</span></code> ,如果 <code class="docutils literal notranslate"><span class="pre">d</span></code> 定义了 <code class="docutils literal notranslate"><span class="pre">__get__</span></code> 方法，那么 <code class="docutils literal notranslate"><span class="pre">d.__get__(obj)</span></code> 会依据下面的优先规则被调用。</p>
<p>调用的细节取决于 <code class="docutils literal notranslate"><span class="pre">obj</span></code> 是一个类还是一个实例。另外，描述器只对于新式对象和新式类才起作用。继承于 <code class="docutils literal notranslate"><span class="pre">object</span></code> 的类叫做新式类。</p>
<p>对于对象来讲，方法 <code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__getattribute__()</span></code> 把 <code class="docutils literal notranslate"><span class="pre">b.x</span></code> 变成 <code class="docutils literal notranslate"><span class="pre">type(b).__dict__['x'].__get__(b,</span> <span class="pre">type(b))</span></code> 。具体实现是依据这样的优先顺序：资料描述器优先于实例变量，实例变量优先于非资料描述器，__getattr__()方法(如果对象中包含的话)具有最低的优先级。完整的C语言实现可以在 <a class="reference external" href="https://hg.python.org/cpython/file/2.7/Objects/object.c">Objects/object.c</a> 中 <a class="reference external" href="https://docs.python.org/2/c-api/object.html#c.PyObject_GenericGetAttr">PyObject_GenericGetAttr()</a> 查看。</p>
<p>对于类来讲，方法 <code class="xref py py-meth docutils literal notranslate"><span class="pre">type.__getattribute__()</span></code> 把 <code class="docutils literal notranslate"><span class="pre">B.x</span></code> 变成 <code class="docutils literal notranslate"><span class="pre">B.__dict__['x'].__get__(None,</span> <span class="pre">B)</span></code> 。用Python来描述就是:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="s2">&quot;Emulate type_getattro() in Objects/typeobject.c&quot;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;__get__&#39;</span><span class="p">):</span>
       <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">v</span>
</pre></div>
</div>
<p>其中重要的几点：</p>
<ul class="simple">
<li>描述器的调用是因为 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></li>
<li>重写 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code> 方法会阻止正常的描述器调用</li>
<li><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code> 只对新式类的实例可用</li>
<li><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__getattribute__()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">type.__getattribute__()</span></code> 对 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> 的调用不一样</li>
<li>资料描述器总是比实例字典优先。</li>
<li>非资料描述器可能被实例字典重写。(非资料描述器不如实例字典优先)</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">super()</span></code> 返回的对象同样有一个定制的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code> 方法用来调用描述器。调用 <code class="docutils literal notranslate"><span class="pre">super(B,</span> <span class="pre">obj).m()</span></code> 时会先在 <code class="docutils literal notranslate"><span class="pre">obj.__class__.__mro__</span></code> 中查找与B紧邻的基类A，然后返回 <code class="docutils literal notranslate"><span class="pre">A.__dict__['m'].__get__(obj,</span> <span class="pre">A)</span></code> 。如果不是描述器，原样返回 <code class="docutils literal notranslate"><span class="pre">m</span></code> 。如果实例字典中找不到 <code class="docutils literal notranslate"><span class="pre">m</span></code> ，会回溯继续调用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__getattribute__()</span></code> 查找。(译者注：即在 <code class="docutils literal notranslate"><span class="pre">__mro__</span></code> 中的下一个基类中查找)</p>
<p>注意:在Python 2.2中，如果 <code class="docutils literal notranslate"><span class="pre">m</span></code> 是一个描述器, <code class="docutils literal notranslate"><span class="pre">super(B,</span> <span class="pre">obj).m()</span></code> 只会调用方法 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> 。在Python 2.3中，非资料描述器(除非是个旧式类)也会被调用。 <code class="xref c c-func docutils literal notranslate"><span class="pre">super_getattro()</span></code> 的实现细节在：
<a class="reference external" href="http://svn.python.org/view/python/trunk/Objects/typeobject.c?view=markup">Objects/typeobject.c</a>
，[del] 一个等价的Python实现在 <a class="reference external" href="http://www.python.org/2.2.3/descrintro.html#cooperation">Guido’s Tutorial</a> [/del] (译者注：原文此句已删除，保留供大家参考)。</p>
<p>以上展示了描述器的机理是在  <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code>, 和 <code class="xref py py-class docutils literal notranslate"><span class="pre">super</span></code> 的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code> 方法中实现的。由 <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code> 派生出的类自动的继承这个机理，或者它们有个有类似机理的元类。同样，可以重写类的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code> 方法来关闭这个类的描述器行为。</p>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id14">1.5. 描述器例子</a><a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>下面的代码中定义了一个资料描述器，每次 <code class="docutils literal notranslate"><span class="pre">get</span></code> 和 <code class="docutils literal notranslate"><span class="pre">set</span></code> 都会打印一条消息。重写 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code> 是另一个可以使所有属性拥有这个行为的方法。但是，描述器在监视特定属性的时候是很有用的。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RevealAccess</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A data descriptor that sets and returns values</span>
<span class="sd">       normally and prints a message logging their access.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;var&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">initval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s1">&#39;Retrieving&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span>

    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s1">&#39;Updating&#39;</span> <span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">RevealAccess</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;var &quot;x&quot;&#39;</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">5</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">x</span>
<span class="n">Retrieving</span> <span class="n">var</span> <span class="s2">&quot;x&quot;</span>
<span class="mi">10</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">Updating</span> <span class="n">var</span> <span class="s2">&quot;x&quot;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">x</span>
<span class="n">Retrieving</span> <span class="n">var</span> <span class="s2">&quot;x&quot;</span>
<span class="mi">20</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">y</span>
<span class="mi">5</span>
</pre></div>
</div>
<p>这个协议非常简单，并且提供了令人激动的可能。一些用途实在是太普遍以致于它们被打包成独立的函数。像属性(property), 方法(bound和unbound method), 静态方法和类方法都是基于描述器协议的。</p>
</div>
<div class="section" id="properties">
<h2><a class="toc-backref" href="#id15">1.6. 属性(properties)</a><a class="headerlink" href="#properties" title="永久链接至标题">¶</a></h2>
<p>调用 <code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code> 是建立资料描述器的一种简洁方式，从而可以在访问属性时触发相应的方法调用。这个函数的原型:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fdel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">property</span> <span class="n">attribute</span>
</pre></div>
</div>
<p>下面展示了一个典型应用：定义一个托管属性(Managed Attribute) <code class="docutils literal notranslate"><span class="pre">x</span></code> 。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">getx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__x</span>
    <span class="k">def</span> <span class="nf">setx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">__x</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">def</span> <span class="nf">delx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__x</span>
    <span class="n">x</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">getx</span><span class="p">,</span> <span class="n">setx</span><span class="p">,</span> <span class="n">delx</span><span class="p">,</span> <span class="s2">&quot;I&#39;m the &#39;x&#39; property.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>想要看看 <code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code> 是怎么用描述器实现的？ 这里有一个纯Python的等价实现:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Property</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="s2">&quot;Emulate PyProperty_Type() in Objects/descrobject.c&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fget</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fdel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fget</span> <span class="o">=</span> <span class="n">fget</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fset</span> <span class="o">=</span> <span class="n">fset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fdel</span> <span class="o">=</span> <span class="n">fdel</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doc</span>

    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fget</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">,</span> <span class="s2">&quot;unreadable attribute&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fget</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">,</span> <span class="s2">&quot;can&#39;t set attribute&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fset</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delete__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fdel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">,</span> <span class="s2">&quot;can&#39;t delete attribute&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fdel</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fget</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">fget</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fdel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fset</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">fget</span><span class="p">,</span> <span class="n">fset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fdel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deleter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fdel</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">fget</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fset</span><span class="p">,</span> <span class="n">fdel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
</pre></div>
</div>
<p>当用户接口已经被授权访问属性之后，需求发生一些变化，属性需要进一步处理才能返回给用户。这时 <code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code> 能够提供很大帮助。</p>
<p>例如，一个电子表格类提供了访问单元格的方式: <code class="docutils literal notranslate"><span class="pre">Cell('b10').value</span></code> 。 之后，对这个程序的改善要求在每次访问单元格时重新计算单元格的值。然而，程序员并不想影响那些客户端中直接访问属性的代码。那么解决方案是将属性访问包装在一个属性资料描述器中:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cell</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
    <span class="k">def</span> <span class="nf">getvalue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="s2">&quot;Recalculate cell before returning value&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recalc</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">_value</span>
    <span class="n">value</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">getvalue</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2><a class="toc-backref" href="#id16">1.7. 函数和方法</a><a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<p>Python的面向对象特征是建立在基于函数的环境之上的。非资料描述器把两者无缝地连接起来。</p>
<p>类的字典把方法当做函数存储。在定义类的时候，方法通常用关键字 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code> 和 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code> 来声明。这和创建函数是一样的。唯一的不同之处是类方法的第一个参数用来表示对象实例。Python约定，这个参数通常是 <em>self</em>, 但也可以叫 <em>this</em> 或者其它任何名字。</p>
<p>为了支持方法调用，函数包含一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> 方法以便在属性访问时绑定方法。这就是说所有的函数都是非资料描述器，它们返回绑定(bound)还是非绑定(unbound)的方法取决于他们是被实例调用还是被类调用。用Python代码来描述就是:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Function</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="s2">&quot;Simulate func_descr_get() in Objects/funcobject.c&quot;</span>
        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="p">)</span>
</pre></div>
</div>
<p>下面运行解释器来展示实际情况下函数描述器是如何工作的:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="go">     def f(self, x):</span>
<span class="go">          return x</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">D</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span> <span class="c1"># 存储成一个function</span>
<span class="go">&lt;function f at 0x00C45070&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="o">.</span><span class="n">f</span>             <span class="c1"># 从类来方法，返回unbound method</span>
<span class="go">&lt;unbound method D.f&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">f</span>             <span class="c1"># 从实例来访问，返回bound method</span>
<span class="go">&lt;bound method D.f of &lt;__main__.D object at 0x00B18C90&gt;&gt;</span>
</pre></div>
</div>
<p>从输出来看，绑定方法和非绑定方法是两个不同的类型。它们是在文件
Objects/classobject.c(<a class="reference external" href="http://svn.python.org/view/python/trunk/Objects/classobject.c?view=markup">http://svn.python.org/view/python/trunk/Objects/classobject.c?view=markup</a>)
中用C实现的， <code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethod_Type</span></code>  是一个对象，但是根据 <code class="xref py py-attr docutils literal notranslate"><span class="pre">im_self</span></code> 是否是 <em>NULL</em> (在C中等价于 <em>None</em> ) 而表现不同。</p>
<p>同样，一个方法的表现依赖于 <code class="xref py py-attr docutils literal notranslate"><span class="pre">im_self</span></code> 。如果设置了(意味着bound), 原来的函数(保存在 <code class="xref py py-attr docutils literal notranslate"><span class="pre">im_func</span></code> 中)被调用，并且第一个参数设置成实例。如果unbound, 所有参数原封不动地传给原来的函数。函数 <code class="xref py py-func docutils literal notranslate"><span class="pre">instancemethod_call()</span></code> 的实际C语言实现只是比这个稍微复杂些(有一些类型检查)。</p>
</div>
<div class="section" id="id8">
<h2><a class="toc-backref" href="#id17">1.8. 静态方法和类方法</a><a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>非资料描述器为将函数绑定成方法这种常见模式提供了一个简单的实现机制。</p>
<p>简而言之，函数有个方法 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> ，当函数被当作属性访问时，它就会把函数变成一个实例方法。非资料描述器把 <code class="docutils literal notranslate"><span class="pre">obj.f(*args)</span></code> 的调用转换成 <code class="docutils literal notranslate"><span class="pre">f(obj,</span> <span class="pre">*args)</span></code> 。 调用 <code class="docutils literal notranslate"><span class="pre">klass.f(*args)</span></code> 就变成调用 <code class="docutils literal notranslate"><span class="pre">f(*args)</span></code> 。</p>
<p>下面的表格总结了绑定和它最有用的两个变种:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="39%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Transformation</th>
<th class="head">Called from an
Object</th>
<th class="head">Called from a
Class</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>function</td>
<td>f(obj, *args)</td>
<td>f(*args)</td>
</tr>
<tr class="row-odd"><td>staticmethod</td>
<td>f(*args)</td>
<td>f(*args)</td>
</tr>
<tr class="row-even"><td>classmethod</td>
<td>f(type(obj), *args)</td>
<td>f(klass, *args)</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>静态方法原样返回函数，调用 <code class="docutils literal notranslate"><span class="pre">c.f</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">C.f</span></code> 分别等价于 <code class="docutils literal notranslate"><span class="pre">object.__getattribute__(c,</span> <span class="pre">&quot;f&quot;)</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">object.__getattribute__(C,</span> <span class="pre">&quot;f&quot;)</span></code> 。也就是说，无论是从一个对象还是一个类中，这个函数都会同样地访问到。</p>
<p>那些不需要 <code class="docutils literal notranslate"><span class="pre">self</span></code> 变量的方法适合用做静态方法。</p>
<p>例如, 一个统计包可能包含一个用来做实验数据容器的类。这个类提供了一般的方法，来计算平均数，中位数，以及其他基于数据的描述性统计指标。然而，这个类可能包含一些概念上与统计相关但不依赖具体数据的函数。比如 <code class="docutils literal notranslate"><span class="pre">erf(x)</span></code> 就是一个统计工作中经常用到的，但却不依赖于特定数据的函数。它可以从类或者实例调用: <code class="docutils literal notranslate"><span class="pre">s.erf(1.5)</span> <span class="pre">--&gt;</span> <span class="pre">.9332</span></code>  或者 <code class="docutils literal notranslate"><span class="pre">Sample.erf(1.5)</span> <span class="pre">--&gt;</span> <span class="pre">.9332</span></code>.</p>
<p>既然staticmethod将函数原封不动的返回，那下面的代码看上去就很正常了:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">E</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="go">     def f(x):</span>
<span class="go">          print x</span>
<span class="go">     f = staticmethod(f)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">E</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>利用非资料描述器， <code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code> 的纯Python版本看起来像这样:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">StaticMethod</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
 <span class="s2">&quot;Emulate PyStaticMethod_Type() in Objects/funcobject.c&quot;</span>

 <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>

 <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span>
</pre></div>
</div>
<p>不像静态方法，类方法需要在调用函数之前会在参数列表前添上class的引用作为第一个参数。不管调用者是对象还是类，这个格式是一样的:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">E</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="go">     def f(klass, x):</span>
<span class="go">          return klass.__name__, x</span>
<span class="go">     f = classmethod(f)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">E</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">(&#39;E&#39;, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">(&#39;E&#39;, 3)</span>
</pre></div>
</div>
<p>当一个函数不需要相关的数据做参数而只需要一个类的引用的时候，这个特征就显得很有用了。类方法的一个用途是用来创建不同的类构造器。在Python 2.3中, <code class="xref py py-func docutils literal notranslate"><span class="pre">dict.fromkeys()</span></code> 可以依据一个key列表来创建一个新的字典。等价的Python实现就是:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dict</span><span class="p">:</span>
    <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
    <span class="k">def</span> <span class="nf">fromkeys</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="s2">&quot;Emulate dict_fromkeys() in Objects/dictobject.c&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">klass</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">d</span>
    <span class="n">fromkeys</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">fromkeys</span><span class="p">)</span>
</pre></div>
</div>
<p>现在，一个新的字典就可以这么创建:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="s1">&#39;abracadabra&#39;</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: None, &#39;r&#39;: None, &#39;b&#39;: None, &#39;c&#39;: None, &#39;d&#39;: None}</span>
</pre></div>
</div>
<p>用非资料描述器协议， <code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code> 的纯Python版本实现看起来像这样:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ClassMethod</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
     <span class="s2">&quot;Emulate PyClassMethod_Type() in Objects/funcobject.c&quot;</span>

     <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>

     <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">klass</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
               <span class="n">klass</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
          <span class="k">def</span> <span class="nf">newfunc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
               <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
          <span class="k">return</span> <span class="n">newfunc</span>
</pre></div>
</div>
</div>
</div>


            <div class="cut">***</div>
          </div>
       </div>
     </div>
  </div>
      <div class="clearer"></div>
    </div>
  
  <a href="http://github.com/hit9/PyZh">
    <img style="position: fixed; top: 0; right: 0; border: 0;"
    src="http://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"
    alt="Fork me on GitHub" />
  </a>
  

  
  <div class="footer">
    &copy; Copyright 2013, hit9.
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>. Theme
    <a href="https://github.com/hit9/sphinx-theme-rux">rux</a>.
  </div>

  </body>
</html>